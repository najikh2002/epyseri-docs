{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"epyseri","text":"<p>The epyseri package is created with the aim of simplifying the software development experience, especially when connecting programs with various services. By using this package, engineers no longer need to spend time and effort writing complex code when integrating with different services.</p> <p>For now, in the epyseri package, we will focus on creating integration with Trident Trace first. This approach makes the integration process more comfortable and can potentially reduce common issues that engineers face when integrating with the Trident Trace service.</p>"},{"location":"model/","title":"Usage","text":"<p>Guide for using this package</p>"},{"location":"model/#init","title":"Init","text":"<p>PARAMETERS</p> Name Type Description Default base_url str Base URL of the Trident Trace service required auth_token str Authentication token, default is None opsional app_name str Application name, default is None opsional <p>RETURNS</p> Name Type Description Default ttc str Base URL of the Trident Trace service required <p>USAGE</p> <pre><code>from epyseri import TridentTraceClient\n\nttc = TridentTraceClient(\n    base_url=\"string\",\n    app_name=\"string\",\n    auth_token=\"string\"\n)\n\nprint(ttc.service_domain_id, ttc.service_domain_slug)\n</code></pre>"},{"location":"model/#health","title":"Health","text":"<p>GET <code>/health</code> - Health</p> <p>PARAMETERS</p> Name Type Description Default base_url str Base URL of the Trident Trace service required <p>RETURNS</p> Name Type Description Default ttc str Base URL of the Trident Trace service required <p>USAGE</p> <pre><code>get_health_result = ttc.get_health()\n\nprint(get_health_result)\n</code></pre>"},{"location":"model/#inference","title":"Inference","text":"<p>GET <code>/api/v1/inference</code> - List Inference </p> <p>PARAMETERS</p> Parameter Type Description Default business_domain str The business domain to filter the inferences. limit int (optional) The maximum number of results to return. Default is None. None offset int (optional) The result offset. Default is None. None service_domain_id int (optional) The service domain ID to filter the inferences. Default is None. None service_domain_slug str (optional) The service domain slug to filter the inferences. Default is None. None ai_domain str (optional) The AI domain to filter the inferences. Default is None. None ai_subdomain str (optional) The AI subdomain to filter the inferences. Default is None. None user str (optional) The user to filter the inferences. Default is None. None group_id str (optional) The group ID to filter the inferences. Default is None. None order_by str (optional) The field to order the inferences. Default is None. None <p>RETURNS</p> Returns Type Description Default Any A list of inferences that match the specified parameters. <p>USAGE</p> <pre><code>get_list_inference_res = ttc.get_list_inference(\"string\")\n\nprint(get_list_inference_res)\n</code></pre> <p>POST <code>/api/v1/inference</code> - Create Inference </p> <p>PARAMETERS</p> Parameter Type Description Default data_input str or dict Input data for the inference. data_output str or dict Output data for the inference. inference_time int Time of the inference. ai_domain str AI domain of the inference. ai_subdomain str AI subdomain of the inference. model_version str Version of the model used for the inference. business_domain str Business domain of the inference. user str User who performed the inference. image np.ndarray or str or None (optional) Image data used for the inference. Defaults to None. None group_id str or None (optional) Group ID of the inference. Defaults to None. None service_domain_id int or None (optional) Service domain ID of the inference. Defaults to None. None conf_threshold float or None (optional) Confidence threshold for the inference. Defaults to None. None <p>RETURNS</p> Returns Type Description Default dict or str Response data. <p>USAGE</p> <pre><code>import cv2\n\nimage = cv2.imread(\"./image.jpeg\")\n\npost_inference_res = ttc.post_inference(\n        data_input = \"string\",\n        data_output = \"string\",\n        inference_time = 0,\n        business_domain = \"string\",\n        ai_domain = \"string\",\n        ai_subdomain = \"string\",\n        model_version = \"string\",\n        group_id = \"string\",\n        user = \"test\",\n        image = image,\n)\nprint(post_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference/{inference_uuid}</code> - Detail Inference </p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid str Identifier of the inference. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>get_detail_inference_res = ttc.get_detail_inference(\"74642c5b-c4ad-49f8-b1da-2d482bb424f8\")\n\nprint(get_detail_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference</code> - List Group Inference </p> <p>PARAMETERS</p> Parameter Type Description Default data_input str or dict Input data for the inference. data_output str or dict Output data for the inference. inference_time int Time of the inference. ai_domain str AI domain of the inference. ai_subdomain str AI subdomain of the inference. model_version str Version of the model used for the inference. business_domain str Business domain of the inference. user str User who performed the inference. image np.ndarray or str or None (optional) Image data used for the inference. Defaults to None. None group_id str or None (optional) Group ID of the inference. Defaults to None. None service_domain_id int or None (optional) Service domain ID of the inference. Defaults to None. None conf_threshold float or None (optional) Confidence threshold for the inference. Defaults to None. None <p>RETURNS</p> Returns Type Description Default dict or str Response data. <p>USAGE</p> <pre><code>get_group_inference_res = ttc.get_group_inference(\n    business_domain = \"string\",\n    user=\"string\",\n    limit = 3,\n    offset = 0,\n)\n\nprint(get_group_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference/{group_uuid}</code> - Detail Group Inference </p> <p>PARAMETERS</p> Parameter Type Description Default group_id str Identifier of the group inference. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>get_group_detail_inference_res = ttc.get_detail_group_inference(\"string\")\n\nprint(get_group_detail_inference_res)\n</code></pre> <p>DELETE <code>/api/v1/inference/{inference_uuid}</code> - Delete Inference </p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid str Identifier of the inference to be deleted. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>delete_inference_res = ttc.delete_inference(\"5c462e22-dad0-46eb-9af8-fb7f34a6cf06\")\n\nprint(delete_inference_res)\n</code></pre>"},{"location":"model/#feedback","title":"Feedback","text":"<p>POST <code>/api/v1/inference/{inference_uuid}</code> - Create Feedback</p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid int Identifier of the associated inference. user_reaction bool User's reaction to the inference. user_comment str or dict User's comment on the inference. user str (optional) User who created the feedback. Default is None. None <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>create_feedback_res = ttc.post_feedback(\n    inference_uuid=\"74642c5b-c4ad-49f8-b1da-2d482bb424f8\", \n    user_comment={\n        \"id\": 22,\n        \"user\": \"nama\",\n        \"message\": \"Test \"\n    }, \n    user_reaction=True\n)\n\nprint(create_feedback_res)\n</code></pre> <p>PUT <code>/api/v1/inference/{inference_uuid}</code> - Update Feedback</p> <p>PARAMETERS</p> Parameter Type Description Default uuid str Identifier of the feedback to be updated. inference_uuid str Identifier of the associated inference. user_reaction bool User's updated reaction to the inference. user_comment str or dict User's updated comment on the inference. user str (optional) User who is updating the feedback. None <p>RETURNS</p> Returns Type Description Default Any Response data from the <code>update_feedback</code> method of the CoreAPI object. <p>USAGE</p> <pre><code>delete_inference_res = ttc.delete_inference(\"5c462e22-dad0-46eb-9af8-fb7f34a6cf06\")\n\nprint(delete_inference_res)\n</code></pre>"},{"location":"start/","title":"Getting Started with epyseri","text":"<pre><code>pip install epyseri\n</code></pre>"},{"location":"documentation/CoreAPI/","title":"CoreAPI","text":"Source code in <code>epyseri/integration/trident_trace/core.py</code> <pre><code>class CoreAPI:\n    def __init__(self, base_url, auth_token, api_version=\"/api/v1\") -&gt; None:\n        self.base_url = base_url\n        self.auth_token = auth_token\n        self.api_version = api_version\n\n    def get_health(self) -&gt; dict:\n        api_endpoint = \"/health\" \n        url = get_url(self, api_endpoint, api_version=False)\n        headers = get_headers()\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Health\")['success'] \n\n    # Domain Service\n    def get_domain(self, app_name) -&gt; dict:\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint, params=slugify(app_name))\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url=url, headers=headers)\n        if response.status_code == 200:\n            data = response.json().get('data')\n            return data['id'], data['slug'] if data else (None, None)\n        else:\n            return None, None\n\n    def post_domain(self, app_name) -&gt; str | dict:\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint) \n        headers = get_headers(self.auth_token, json=True)\n        payload = {'name': f\"{app_name}\"}\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)\n        return get_response(response, \"Domain\").get('data', {})\n\n    def delete_domain(self, domain_id):\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint, params=domain_id)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.delete(url, headers=headers)\n        return get_response(response, \"Domain\")['success']\n\n    # Inference Service\n    def get_list_inference(self, **kwargs):\n        api_endpoint = f\"{self.api_version}/inference\"\n        url = f\"{self.base_url}{api_endpoint}\"\n        headers = get_headers(self.auth_token)\n        filtered_kwargs = {key: value for key, value in kwargs.items() if value is not None}\n        if filtered_kwargs:\n            url += \"?\" + \"&amp;\".join(f\"{key}={value}\" for key, value in filtered_kwargs.items())\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"List Inference\")\n\n    def get_detail_inference(self, inference_uuid):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint, inference_uuid)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Detail Inference\")\n\n    def post_inference(self, body):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = body\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)  \n        return get_response(response, \"Inference\")\n\n    def delete_inference(self, inference_uuid):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint, params=inference_uuid)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.delete(url, headers=headers)\n        return get_response(response, \"Inference\")['success']\n\n    def get_group_inference(self, **kwargs):\n        api_endpoint = \"/inference/group\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token)\n        params = {key:value for key, value in dict(**kwargs).items() if value is not None}\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers, params=params)\n        return get_response(response, \"List Group Inference\")\n\n    def get_detail_group_inference(self, group_id):\n        api_endpoint = \"/inference/group\"\n        url = get_url(self, api_endpoint, group_id)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Detail Group Inference\")\n\n    # Feedback Service\n    def post_feedback(self, inference_uuid, user_reaction, user_comment, user):\n        api_endpoint = \"/feedback\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = {\n            \"inference_uuid\": inference_uuid,\n            \"user\": user,\n            \"user_reaction\": 1 if user_reaction else 0,\n            \"user_comment\": json.dumps(user_comment) if isinstance(user_comment, dict) else user_comment, \n        }\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)\n        return get_response(response, \"Feedback\")\n\n    def update_feedback(self, uuid, inference_uuid, user_reaction, user_comment, user):\n        api_endpoint = \"/feedback\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = {\n            \"uuid\": uuid,\n            \"inference_uuid\": inference_uuid,\n            \"user\": user,\n            \"user_reaction\": 1 if user_reaction else 0,\n            \"user_comment\": json.dumps(user_comment) if isinstance(user_comment, dict) else user_comment, \n        } \n        with httpx.Client() as client:\n            response = client.put(url, headers=headers, json=payload)   \n        return get_response(response, \"Feedback\")\n</code></pre>"},{"location":"documentation/Helper/","title":"Helper","text":"Source code in <code>epyseri/integration/trident_trace/helper.py</code> <pre><code>class Wrapper:\n    # we can't have a non-default-constructible Metric implementation at module level\n    class ColorMetric:\n        def __init__(\n            self,\n            color_name: str,\n            hue_filters: Union[List, List[List]],\n            saturation_filters=[50, 255],\n            value_filters=[20, 255],\n        ):\n            self.color_name = color_name\n            self.hue_filters = hue_filters\n            self.saturation_filters = saturation_filters\n            self.value_filters = value_filters\n\n            hsv_test = all(\n                0 &lt;= item &lt;= 179 for item in self.__flatten_nested_lists(hue_filters)\n            )\n            if not hsv_test:\n                raise ValueError(\"Hue parameter should be in [0, 179]\")\n\n            saturation_test = all(0 &lt;= item &lt;= 255 for item in saturation_filters)\n            if not saturation_test:\n                raise ValueError(\"Saturation parameter should be in [0, 255]\")\n\n            value_test = all(0 &lt;= item &lt;= 255 for item in value_filters)\n            if not value_test:\n                raise ValueError(\"Value parameter should be in [0, 255]\")\n\n        def __flatten_nested_lists(self, nested_list):\n            out = []\n\n            for item in nested_list:\n                if isinstance(item, list):\n                    out.extend(self.__flatten_nested_lists(item))\n                else:\n                    out.append(item)\n            return out\n\n        def compute(self, image_rgb: ndarray):\n            image = image_rgb\n            if self.color_name.lower() != \"red\":\n                mask = cv2.inRange(\n                    image,\n                    np.array(\n                        [\n                            self.hue_filters[0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                )\n                ratio = np.sum(mask &gt; 0) / (image.shape[0] * image.shape[1])\n\n            else:\n                lower_spectrum = [\n                    np.array(\n                        [\n                            self.hue_filters[0][0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[0][1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                ]\n                upper_spectrum = [\n                    np.array(\n                        [\n                            self.hue_filters[1][0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[1][1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                ]\n\n                lower_mask = cv2.inRange(image, lower_spectrum[0], lower_spectrum[1])\n                upper_mask = cv2.inRange(image, upper_spectrum[0], upper_spectrum[1])\n                mask = lower_mask + upper_mask\n                ratio = np.sum(mask &gt; 0) / (image.shape[0] * image.shape[1])\n            return ratio\n</code></pre>"},{"location":"documentation/Schemas/","title":"Schemas","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>epyseri/integration/trident_trace/schemas.py</code> <pre><code>class InferenceSchema(BaseModel):\n    business_domain: str = \"string\",\n    limit: int = 0,\n    offset: int = 0,\n    service_domain_id: Optional[List[int]] = None,\n    service_domain_slug: Optional[List[str]] = None,\n    ai_domain: str = \"string\",\n    ai_subdomain: str = \"string\",\n    user: str = \"string\",\n    group_id: str = \"string\",\n    order_by: str = \"string\"\n</code></pre> <p>             Bases: <code>BaseModel</code></p> Source code in <code>epyseri/integration/trident_trace/schemas.py</code> <pre><code>class MetadataVisionSchema(BaseModel):\n    image_size_kb: float\n    area: float\n    aspect_ratio_hw: float\n    blue_values: float\n    blur: float\n    brightness: float\n    contrast: float\n    green_values: float\n    red_values: float\n    sharpness: float\n    height: int\n    width: int\n    channels: int\n    confidence_threshold: float | None\n    saturation_std: float\n    saturation_mean: float\n</code></pre>"},{"location":"documentation/TridentTraceClient/","title":"TridentTraceClient","text":""},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient","title":"<code>TridentTraceClient</code>","text":"Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>class TridentTraceClient:\n    def __init__(\n            self, \n            base_url: str, \n            auth_token: str = None,\n            app_name: str = None,\n        ) -&gt; None:  \n        \"\"\"\n        Initializes the TridentTraceClient object.\n\n        Parameters:\n            base_url (str): Base URL of the Trident Trace service.\n            auth_token (str): Authentication token, default is None.\n            app_name (str): Application name, default is None.\n            user (str): User name, default is None.\n\n        Returns:\n            None\n        \"\"\"\n        self.base_url: str = base_url\n        self.auth_token: str = auth_token\n        self.app_name = app_name\n        self.core = CoreAPI(base_url=self.base_url, auth_token=self.auth_token)\n        self.service_domain_id = None\n        self.service_domain_slug = None\n\n        self.initialize()\n\n    def __auto_setup(self, app_name):\n        \"\"\"\n        Automatically sets up the service domain based on the app_name.\n\n        Parameters:\n            app_name (str): Application name.\n\n        Returns:\n            (int, str): A tuple containing domain_id and domain_slug.\n        \"\"\"\n        domain_id, domain_slug = self.__get_domain(app_name)\n        if domain_id is None:\n            domain_slug_res = self.__post_domain(app_name)\n            domain_id, domain_slug = self.__get_domain(domain_slug_res)\n        return domain_id, domain_slug\n\n    def initialize(self):\n        \"\"\"\n        Initializes service_domain_id and service_domain_slug if app_name is specified.\n        \"\"\"\n        if self.app_name:\n            self.service_domain_id, self.service_domain_slug = self.__auto_setup(self.app_name)\n\n\n    def get_health(self) -&gt; dict | str:\n        \"\"\"\n        Retrieves health information from the specified URL using httpx.\n\n        Returns:\n            (dict | str): Response data.\n\n        Basic Usage:\n            &gt;&gt;&gt; result = get_health()\n            &gt;&gt;&gt; print(result)\n        \"\"\"\n        health_data = self.core.get_health()\n        return health_data\n\n\n    def __get_domain(self, app_name: str) -&gt; dict | str:\n        \"\"\"\n        Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.\n\n        Parameters:\n            app_name (str): Nama aplikasi.\n\n        Returns:\n            (dict | str): Data respons atau pesan kesalahan.\n        \"\"\"\n        domain_get_data = self.core.get_domain(app_name)\n        return domain_get_data\n\n    def __post_domain(self, app_name: str) -&gt; dict | str:\n        \"\"\"\n        DOMAIN SERVICE Creates a new domain with the given app_name.\n\n        Parameters:\n            app_name (str): Application name.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        domain_post_data = self.core.post_domain(app_name)\n        return domain_post_data\n\n    def delete_domain(self, domain_id: int) -&gt; dict | str:\n        \"\"\"\n        Deletes a domain with the specified domain_id.\n\n        Parameters:\n            domain_id: Identifier of the domain to be deleted.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        domain_delete_data = self.core.delete_domain(domain_id)\n        return domain_delete_data\n\n    def get_list_inference(\n            self,\n            business_domain: str,\n            limit: int = None,\n            offset: int = None,\n            service_domain_id: Optional[int] = None,\n            service_domain_slug: Optional[str] = None,\n            ai_domain: str = None,\n            ai_subdomain: str = None,\n            user: str = None,\n            group_id: str = None,\n            order_by: str = None\n        ):\n        \"\"\"\n        INFERENCE SERVICES Get a list of inferences based on specified parameters.\n\n        Parameters:\n            business_domain (str): Business domain.\n            limit (int): Maximum number of results to return.\n            offset (int): Result offset.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_list_data = self.core.get_list_inference(\n            business_domain=business_domain,\n            limit=limit,\n            offset=offset,\n            service_domain_id=service_domain_id,\n            service_domain_slug=service_domain_slug,\n            ai_domain=ai_domain,\n            ai_subdomain=ai_subdomain,\n            user=user,\n            group_id=group_id,\n            order_by=order_by\n        )\n        # inference_get_list_data_result = convert_data(inference_get_list_data)\n        return inference_get_list_data\n\n    def get_detail_inference(self, inference_uuid) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Get detailed information about a specific inference.\n\n        Parameters:\n            inference_uuid: Identifier of the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_detail_data_result = self.core.get_detail_inference(inference_uuid)\n        if inference_get_detail_data_result:\n            for d_feed in inference_get_detail_data_result['data']['feedbacks']:\n                comments = d_feed['user_comment']\n                if \"{\" in comments[0] and  \"}\" in comments[-1]:\n                    d_feed['user_comment'] = json.loads(comments)\n        return inference_get_detail_data_result\n\n    def post_inference(\n            self,\n            data_input: str | dict,\n            data_output: str | dict,\n            inference_time: int,\n            ai_domain: str,\n            ai_subdomain: str,\n            model_version: str,\n            business_domain: str,\n            user: str, \n            image: np.ndarray | str | None = None, \n            group_id: str | None = None,\n            service_domain_id: int | None = None,\n            conf_thershold: float | None = None\n        ) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Create a new inference with the specified parameters.\n\n        Parameters:\n            data_input: Input data for the inference.\n            data_output: Output data for the inference.\n            inference_time: Time of the inference.\n            ...\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        meta_data_vision = None\n        if isinstance(image, np.ndarray):\n            meta_data_vision = FeaturesImage.compute_features(image)\n            meta_data_vision['confidence_threshold'] = conf_thershold\n            meta_data_vision = MetadataVisionSchema(**meta_data_vision)\n\n        if isinstance(data_input, dict):\n            data_input = json.dumps(data_input)\n\n        if isinstance(data_output, dict):\n            data_output = json.dumps(data_output)\n\n        body = {\n            \"data_input\": data_input,\n            \"data_output\": data_output,\n            \"inference_time\": inference_time,\n            \"business_domain\": business_domain,\n            \"service_domain_id\": service_domain_id or self.service_domain_id,\n            \"ai_domain\": ai_domain,\n            \"ai_subdomain\": ai_subdomain,\n            \"model_version\": model_version,\n            \"user\": user \n        }\n        if meta_data_vision:\n            body[\"meta_data_vision\"] = meta_data_vision.model_dump()\n        if group_id:\n            body[\"group_id\"] = group_id\n        inference_create_data = self.core.post_inference(body)\n        return inference_create_data\n\n    def delete_inference(self, inference_uuid: str) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Delete an inference with the specified inference_uuid.\n\n        Parameters:\n            inference_uuid: Identifier of the inference to be deleted.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_delete_data = self.core.delete_inference(inference_uuid)\n        return inference_delete_data\n\n    def get_group_inference(\n            self,\n            business_domain: str,\n            user: str = None,\n            limit: int = None,\n            offset: int = None,\n            service_domain_id: Optional[int] = None,\n            service_domain_slug: Optional[str] = None,\n            ai_domain: str = None,\n            ai_subdomain: str = None,\n            group_id: str = None,\n            start_date: str = None,\n            end_date: str = None\n        ):\n            \"\"\"\n            INFERENCE SERVICES Get a list of group inferences based on specified parameters.\n\n            Parameters:\n                business_domain (str): Business domain.\n                limit (int): Maximum number of results to return.\n                offset (int): Result offset.\n                ...\n\n            Returns:\n                (dict | str): Response data.\n            \"\"\"\n            inference_get_group_data = self.core.get_group_inference(\n                business_domain = business_domain,\n                limit = limit,\n                offset = offset,\n                service_domain_id = service_domain_id,\n                service_domain_slug = service_domain_slug,\n                ai_domain = ai_domain,\n                ai_subdomain = ai_subdomain,\n                user = user,\n                group_id = group_id,\n                start_date = start_date,\n                end_date = end_date\n            )\n\n            inference_get_group_data_result = convert_data(inference_get_group_data)\n            return inference_get_group_data_result\n\n\n    def get_detail_group_inference(self, group_id: str):\n        \"\"\"\n        INFERENCE SERVICES Get detailed information about a specific group inference.\n\n        Parameters:\n            group_id: Identifier of the group inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_detail_group_data = self.core.get_detail_group_inference(group_id)\n        return inference_get_detail_group_data\n\n\n    def post_feedback(\n            self, \n            inference_uuid, \n            user_reaction, \n            user_comment: str | dict, \n            user=None\n        ):\n        \"\"\"\n        FEEDBACK SERVICE Create feedback for a specific inference.\n\n        Parameters:\n            inference_uuid: Identifier of the associated inference.\n            user_reaction: User's reaction to the inference.\n            user_comment: User's comment on the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        feedback_create_data = self.core.post_feedback(\n            inference_uuid = inference_uuid, \n            user_reaction = user_reaction, \n            user_comment = user_comment, \n            user = user \n        )\n        return feedback_create_data\n\n    def update_feedback(\n            self, \n            uuid, \n            inference_uuid, \n            user_reaction: bool, \n            user_comment: str | dict, \n            user=None\n        ):\n        \"\"\"\n        FEEDBACK SERVICE Update feedback with the specified parameters.\n\n        Parameters:\n            uuid: Identifier of the feedback.\n            inference_uuid: Identifier of the associated inference.\n            user_reaction: User's updated reaction to the inference.\n            user_comment: User's updated comment on the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        feedback_update_data = self.core.update_feedback(\n            uuid = uuid,\n            inference_uuid = inference_uuid, \n            user_reaction = user_reaction, \n            user_comment = user_comment, \n            user = user \n        )\n        return feedback_update_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__auto_setup","title":"<code>__auto_setup(app_name)</code>","text":"<p>Automatically sets up the service domain based on the app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Application name.</p> required <p>Returns:</p> Type Description <code>(int, str)</code> <p>A tuple containing domain_id and domain_slug.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __auto_setup(self, app_name):\n    \"\"\"\n    Automatically sets up the service domain based on the app_name.\n\n    Parameters:\n        app_name (str): Application name.\n\n    Returns:\n        (int, str): A tuple containing domain_id and domain_slug.\n    \"\"\"\n    domain_id, domain_slug = self.__get_domain(app_name)\n    if domain_id is None:\n        domain_slug_res = self.__post_domain(app_name)\n        domain_id, domain_slug = self.__get_domain(domain_slug_res)\n    return domain_id, domain_slug\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__get_domain","title":"<code>__get_domain(app_name)</code>","text":"<p>Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Nama aplikasi.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Data respons atau pesan kesalahan.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __get_domain(self, app_name: str) -&gt; dict | str:\n    \"\"\"\n    Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.\n\n    Parameters:\n        app_name (str): Nama aplikasi.\n\n    Returns:\n        (dict | str): Data respons atau pesan kesalahan.\n    \"\"\"\n    domain_get_data = self.core.get_domain(app_name)\n    return domain_get_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__init__","title":"<code>__init__(base_url, auth_token=None, app_name=None)</code>","text":"<p>Initializes the TridentTraceClient object.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of the Trident Trace service.</p> required <code>auth_token</code> <code>str</code> <p>Authentication token, default is None.</p> <code>None</code> <code>app_name</code> <code>str</code> <p>Application name, default is None.</p> <code>None</code> <code>user</code> <code>str</code> <p>User name, default is None.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __init__(\n        self, \n        base_url: str, \n        auth_token: str = None,\n        app_name: str = None,\n    ) -&gt; None:  \n    \"\"\"\n    Initializes the TridentTraceClient object.\n\n    Parameters:\n        base_url (str): Base URL of the Trident Trace service.\n        auth_token (str): Authentication token, default is None.\n        app_name (str): Application name, default is None.\n        user (str): User name, default is None.\n\n    Returns:\n        None\n    \"\"\"\n    self.base_url: str = base_url\n    self.auth_token: str = auth_token\n    self.app_name = app_name\n    self.core = CoreAPI(base_url=self.base_url, auth_token=self.auth_token)\n    self.service_domain_id = None\n    self.service_domain_slug = None\n\n    self.initialize()\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__post_domain","title":"<code>__post_domain(app_name)</code>","text":"<p>DOMAIN SERVICE Creates a new domain with the given app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Application name.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __post_domain(self, app_name: str) -&gt; dict | str:\n    \"\"\"\n    DOMAIN SERVICE Creates a new domain with the given app_name.\n\n    Parameters:\n        app_name (str): Application name.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    domain_post_data = self.core.post_domain(app_name)\n    return domain_post_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.delete_domain","title":"<code>delete_domain(domain_id)</code>","text":"<p>Deletes a domain with the specified domain_id.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>int</code> <p>Identifier of the domain to be deleted.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def delete_domain(self, domain_id: int) -&gt; dict | str:\n    \"\"\"\n    Deletes a domain with the specified domain_id.\n\n    Parameters:\n        domain_id: Identifier of the domain to be deleted.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    domain_delete_data = self.core.delete_domain(domain_id)\n    return domain_delete_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.delete_inference","title":"<code>delete_inference(inference_uuid)</code>","text":"<p>INFERENCE SERVICES Delete an inference with the specified inference_uuid.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <code>str</code> <p>Identifier of the inference to be deleted.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def delete_inference(self, inference_uuid: str) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Delete an inference with the specified inference_uuid.\n\n    Parameters:\n        inference_uuid: Identifier of the inference to be deleted.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_delete_data = self.core.delete_inference(inference_uuid)\n    return inference_delete_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_detail_group_inference","title":"<code>get_detail_group_inference(group_id)</code>","text":"<p>INFERENCE SERVICES Get detailed information about a specific group inference.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Identifier of the group inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_detail_group_inference(self, group_id: str):\n    \"\"\"\n    INFERENCE SERVICES Get detailed information about a specific group inference.\n\n    Parameters:\n        group_id: Identifier of the group inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_detail_group_data = self.core.get_detail_group_inference(group_id)\n    return inference_get_detail_group_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_detail_inference","title":"<code>get_detail_inference(inference_uuid)</code>","text":"<p>INFERENCE SERVICES Get detailed information about a specific inference.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <p>Identifier of the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_detail_inference(self, inference_uuid) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Get detailed information about a specific inference.\n\n    Parameters:\n        inference_uuid: Identifier of the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_detail_data_result = self.core.get_detail_inference(inference_uuid)\n    if inference_get_detail_data_result:\n        for d_feed in inference_get_detail_data_result['data']['feedbacks']:\n            comments = d_feed['user_comment']\n            if \"{\" in comments[0] and  \"}\" in comments[-1]:\n                d_feed['user_comment'] = json.loads(comments)\n    return inference_get_detail_data_result\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_group_inference","title":"<code>get_group_inference(business_domain, user=None, limit=None, offset=None, service_domain_id=None, service_domain_slug=None, ai_domain=None, ai_subdomain=None, group_id=None, start_date=None, end_date=None)</code>","text":"<p>INFERENCE SERVICES Get a list of group inferences based on specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>business_domain</code> <code>str</code> <p>Business domain.</p> required <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_group_inference(\n        self,\n        business_domain: str,\n        user: str = None,\n        limit: int = None,\n        offset: int = None,\n        service_domain_id: Optional[int] = None,\n        service_domain_slug: Optional[str] = None,\n        ai_domain: str = None,\n        ai_subdomain: str = None,\n        group_id: str = None,\n        start_date: str = None,\n        end_date: str = None\n    ):\n        \"\"\"\n        INFERENCE SERVICES Get a list of group inferences based on specified parameters.\n\n        Parameters:\n            business_domain (str): Business domain.\n            limit (int): Maximum number of results to return.\n            offset (int): Result offset.\n            ...\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_group_data = self.core.get_group_inference(\n            business_domain = business_domain,\n            limit = limit,\n            offset = offset,\n            service_domain_id = service_domain_id,\n            service_domain_slug = service_domain_slug,\n            ai_domain = ai_domain,\n            ai_subdomain = ai_subdomain,\n            user = user,\n            group_id = group_id,\n            start_date = start_date,\n            end_date = end_date\n        )\n\n        inference_get_group_data_result = convert_data(inference_get_group_data)\n        return inference_get_group_data_result\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_health","title":"<code>get_health()</code>","text":"<p>Retrieves health information from the specified URL using httpx.</p> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Basic Usage <p>result = get_health() print(result)</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_health(self) -&gt; dict | str:\n    \"\"\"\n    Retrieves health information from the specified URL using httpx.\n\n    Returns:\n        (dict | str): Response data.\n\n    Basic Usage:\n        &gt;&gt;&gt; result = get_health()\n        &gt;&gt;&gt; print(result)\n    \"\"\"\n    health_data = self.core.get_health()\n    return health_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_list_inference","title":"<code>get_list_inference(business_domain, limit=None, offset=None, service_domain_id=None, service_domain_slug=None, ai_domain=None, ai_subdomain=None, user=None, group_id=None, order_by=None)</code>","text":"<p>INFERENCE SERVICES Get a list of inferences based on specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>business_domain</code> <code>str</code> <p>Business domain.</p> required <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_list_inference(\n        self,\n        business_domain: str,\n        limit: int = None,\n        offset: int = None,\n        service_domain_id: Optional[int] = None,\n        service_domain_slug: Optional[str] = None,\n        ai_domain: str = None,\n        ai_subdomain: str = None,\n        user: str = None,\n        group_id: str = None,\n        order_by: str = None\n    ):\n    \"\"\"\n    INFERENCE SERVICES Get a list of inferences based on specified parameters.\n\n    Parameters:\n        business_domain (str): Business domain.\n        limit (int): Maximum number of results to return.\n        offset (int): Result offset.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_list_data = self.core.get_list_inference(\n        business_domain=business_domain,\n        limit=limit,\n        offset=offset,\n        service_domain_id=service_domain_id,\n        service_domain_slug=service_domain_slug,\n        ai_domain=ai_domain,\n        ai_subdomain=ai_subdomain,\n        user=user,\n        group_id=group_id,\n        order_by=order_by\n    )\n    # inference_get_list_data_result = convert_data(inference_get_list_data)\n    return inference_get_list_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.initialize","title":"<code>initialize()</code>","text":"<p>Initializes service_domain_id and service_domain_slug if app_name is specified.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def initialize(self):\n    \"\"\"\n    Initializes service_domain_id and service_domain_slug if app_name is specified.\n    \"\"\"\n    if self.app_name:\n        self.service_domain_id, self.service_domain_slug = self.__auto_setup(self.app_name)\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.post_feedback","title":"<code>post_feedback(inference_uuid, user_reaction, user_comment, user=None)</code>","text":"<p>FEEDBACK SERVICE Create feedback for a specific inference.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <p>Identifier of the associated inference.</p> required <code>user_reaction</code> <p>User's reaction to the inference.</p> required <code>user_comment</code> <code>str | dict</code> <p>User's comment on the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def post_feedback(\n        self, \n        inference_uuid, \n        user_reaction, \n        user_comment: str | dict, \n        user=None\n    ):\n    \"\"\"\n    FEEDBACK SERVICE Create feedback for a specific inference.\n\n    Parameters:\n        inference_uuid: Identifier of the associated inference.\n        user_reaction: User's reaction to the inference.\n        user_comment: User's comment on the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    feedback_create_data = self.core.post_feedback(\n        inference_uuid = inference_uuid, \n        user_reaction = user_reaction, \n        user_comment = user_comment, \n        user = user \n    )\n    return feedback_create_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.post_inference","title":"<code>post_inference(data_input, data_output, inference_time, ai_domain, ai_subdomain, model_version, business_domain, user, image=None, group_id=None, service_domain_id=None, conf_thershold=None)</code>","text":"<p>INFERENCE SERVICES Create a new inference with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>data_input</code> <code>str | dict</code> <p>Input data for the inference.</p> required <code>data_output</code> <code>str | dict</code> <p>Output data for the inference.</p> required <code>inference_time</code> <code>int</code> <p>Time of the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def post_inference(\n        self,\n        data_input: str | dict,\n        data_output: str | dict,\n        inference_time: int,\n        ai_domain: str,\n        ai_subdomain: str,\n        model_version: str,\n        business_domain: str,\n        user: str, \n        image: np.ndarray | str | None = None, \n        group_id: str | None = None,\n        service_domain_id: int | None = None,\n        conf_thershold: float | None = None\n    ) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Create a new inference with the specified parameters.\n\n    Parameters:\n        data_input: Input data for the inference.\n        data_output: Output data for the inference.\n        inference_time: Time of the inference.\n        ...\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    meta_data_vision = None\n    if isinstance(image, np.ndarray):\n        meta_data_vision = FeaturesImage.compute_features(image)\n        meta_data_vision['confidence_threshold'] = conf_thershold\n        meta_data_vision = MetadataVisionSchema(**meta_data_vision)\n\n    if isinstance(data_input, dict):\n        data_input = json.dumps(data_input)\n\n    if isinstance(data_output, dict):\n        data_output = json.dumps(data_output)\n\n    body = {\n        \"data_input\": data_input,\n        \"data_output\": data_output,\n        \"inference_time\": inference_time,\n        \"business_domain\": business_domain,\n        \"service_domain_id\": service_domain_id or self.service_domain_id,\n        \"ai_domain\": ai_domain,\n        \"ai_subdomain\": ai_subdomain,\n        \"model_version\": model_version,\n        \"user\": user \n    }\n    if meta_data_vision:\n        body[\"meta_data_vision\"] = meta_data_vision.model_dump()\n    if group_id:\n        body[\"group_id\"] = group_id\n    inference_create_data = self.core.post_inference(body)\n    return inference_create_data\n</code></pre>"},{"location":"documentation/TridentTraceClient/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.update_feedback","title":"<code>update_feedback(uuid, inference_uuid, user_reaction, user_comment, user=None)</code>","text":"<p>FEEDBACK SERVICE Update feedback with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <p>Identifier of the feedback.</p> required <code>inference_uuid</code> <p>Identifier of the associated inference.</p> required <code>user_reaction</code> <code>bool</code> <p>User's updated reaction to the inference.</p> required <code>user_comment</code> <code>str | dict</code> <p>User's updated comment on the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def update_feedback(\n        self, \n        uuid, \n        inference_uuid, \n        user_reaction: bool, \n        user_comment: str | dict, \n        user=None\n    ):\n    \"\"\"\n    FEEDBACK SERVICE Update feedback with the specified parameters.\n\n    Parameters:\n        uuid: Identifier of the feedback.\n        inference_uuid: Identifier of the associated inference.\n        user_reaction: User's updated reaction to the inference.\n        user_comment: User's updated comment on the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    feedback_update_data = self.core.update_feedback(\n        uuid = uuid,\n        inference_uuid = inference_uuid, \n        user_reaction = user_reaction, \n        user_comment = user_comment, \n        user = user \n    )\n    return feedback_update_data\n</code></pre>"},{"location":"documentation/Utils/","title":"Utils","text":""},{"location":"documentation/Utils/#epyseri.integration.trident_trace.utils.convert_data","title":"<code>convert_data(inference_data, convert_to_dict=True)</code>","text":"<p>Converts the 'data_input', 'data_output', and 'user_comment' fields from JSON strings to dictionaries in the provided 'inference_data' object. Automatic conversion is applied if 'convert_to_dict' is True.</p> <p>Parameters: - inference_data (dict): The input data containing 'data' and potentially 'feedback'. - convert_to_dict (bool): A flag indicating whether to automatically convert the fields. Default is True.</p> <p>Returns: - list: A list of dictionaries containing the converted data.</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def convert_data(inference_data, convert_to_dict=True):\n    \"\"\"\n    Converts the 'data_input', 'data_output', and 'user_comment' fields from JSON strings to dictionaries\n    in the provided 'inference_data' object. Automatic conversion is applied if 'convert_to_dict' is True.\n\n    Parameters:\n    - inference_data (dict): The input data containing 'data' and potentially 'feedback'.\n    - convert_to_dict (bool): A flag indicating whether to automatically convert the fields. Default is True.\n\n    Returns:\n    - list: A list of dictionaries containing the converted data.\n    \"\"\"\n    if inference_data and inference_data.get('data') and len(inference_data['data']) &gt; 0:\n        def is_json_string(data):\n            try:\n                json.loads(data)\n                return True\n            except (json.JSONDecodeError, TypeError):\n                return False\n\n        converted_data = []\n\n        for d in inference_data.get('data', []):\n            if convert_to_dict:\n                if is_json_string(d.get('data_input')):\n                    d['data_input'] = json.loads(d['data_input'])\n                if is_json_string(d.get('data_output')):\n                    d['data_output'] = json.loads(d['data_output'])\n            if d.get('feedback'):\n                for fb in d.get('feedback'):\n                    if is_json_string(fb.get('user_comment')):\n                        fb['user_comment'] = json.loads(fb['user_comment'])\n\n            converted_data.append(d)\n\n        return converted_data\n    else:\n        return None\n</code></pre>"},{"location":"documentation/Utils/#epyseri.integration.trident_trace.utils.get_headers","title":"<code>get_headers(auth_token=None, json=False)</code>","text":"<p>Generate headers for HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>auth_token (str</code> <p>Authentication token for authorization.</p> required <code>-</code> <code>json (bool</code> <p>If True, sets 'Content-Type' to 'application/json'.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the generated headers.</p> Example <p>get_headers(auth_token=\"your_token\", json=True) {'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': 'Bearer your_token'}</p> <p>get_headers(auth_token=\"your_token\") {'Accept': 'application/json', 'Authorization': 'Bearer your_token'}</p> <p>get_headers() {'Accept': 'application/json'}</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_headers(auth_token: str = None, json: bool = False) -&gt; dict:\n    \"\"\"\n    Generate headers for HTTP requests.\n\n    Parameters:\n        - auth_token (str, optional): Authentication token for authorization.\n        - json (bool, optional): If True, sets 'Content-Type' to 'application/json'.\n\n    Returns:\n        dict: A dictionary containing the generated headers.\n\n    Example:\n        &gt;&gt;&gt; get_headers(auth_token=\"your_token\", json=True)\n        {'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': 'Bearer your_token'}\n\n        &gt;&gt;&gt; get_headers(auth_token=\"your_token\")\n        {'Accept': 'application/json', 'Authorization': 'Bearer your_token'}\n\n        &gt;&gt;&gt; get_headers()\n        {'Accept': 'application/json'}\n    \"\"\"\n    if auth_token:\n        if json:\n            headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'Authorization': f\"Bearer {auth_token}\"\n            }\n        else:\n            headers = {\n                'Accept': 'application/json',\n                'Authorization': f\"Bearer {auth_token}\"\n            }\n    else:\n        headers = {\n            'Accept': 'application/json'\n        }\n\n    return headers\n</code></pre>"},{"location":"documentation/Utils/#epyseri.integration.trident_trace.utils.get_response","title":"<code>get_response(response, service)</code>","text":"<p>Processes an HTTP response object and returns the JSON content if the status code is 200.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>response (httpx.Response</code> <p>The response object from an HTTP request.</p> required <code>-</code> <code>service (str</code> <p>The name of the service or endpoint called, used in error messages.</p> required <p>Returns:</p> Type Description <ul> <li>dict or None: The JSON content of the response if the status code is 200, or None if the status code is 404.</li> </ul> <p>Raises:</p> Type Description <code>-Exception</code> <p>Raised if the status code is 401 or any other code. The error message includes information about the status code, request method, service, and response text.</p> Example <p>response = client.get(url, headers=headers) result = get_response(response, \"ExampleService\")</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_response(response, service):\n    \"\"\"\n    Processes an HTTP response object and returns the JSON content if the status code is 200.\n\n    Parameters:\n        - response (httpx.Response): The response object from an HTTP request.\n        - service (str): The name of the service or endpoint called, used in error messages.\n\n    Returns:\n        - dict or None: The JSON content of the response if the status code is 200, or None if the status code is 404.\n\n    Raises:\n        - Exception: Raised if the status code is 401 or any other code. The error message includes information about the status code, request method, service, and response text.\n\n    Example:\n        &gt;&gt;&gt; response = client.get(url, headers=headers)\n        &gt;&gt;&gt; result = get_response(response, \"ExampleService\")\n    \"\"\"\n    if response.status_code == 200:\n        return response.json()\n    elif response.status_code == 401:\n        raise Exception(\"Access Denied: Insufficient Authentication Permissions.\")\n    elif response.status_code == 404:\n        return None\n    else:\n        raise Exception(f\"[{response.status_code}] Error {response.request.method} {service} to Trident Trace, {response.text}\")\n</code></pre>"},{"location":"documentation/Utils/#epyseri.integration.trident_trace.utils.get_url","title":"<code>get_url(self, api_endpoint, params=None, api_version=True)</code>","text":"<p>Generates a complete URL by incorporating the endpoint, API version, and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>api_endpoint (str</code> <p>The endpoint or service path within the API.</p> required <code>-</code> <code>params (str</code> <p>Optional parameter to be added to the URL.</p> required <p>Returns:</p> Type Description <ul> <li>str: The complete URL consisting of the base URL, API version, endpoint, and optional parameter.</li> </ul> Example <p>url = get_url(\"/health\") print(url) \"https://baseurl.com/api/v1/health\"</p> <p>url_params = get_url(\"/users\", params=\"123\") print(url_params) \"https://baseurl.com/api/v1/users/123\"</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_url(self, api_endpoint, params=None, api_version=True):\n    \"\"\"\n    Generates a complete URL by incorporating the endpoint, API version, and optional parameters.\n\n    Parameters:\n        - api_endpoint (str): The endpoint or service path within the API.\n        - params (str, optional): Optional parameter to be added to the URL.\n\n    Returns:\n        - str: The complete URL consisting of the base URL, API version, endpoint, and optional parameter.\n\n    Example:\n        &gt;&gt;&gt; url = get_url(\"/health\")\n        &gt;&gt;&gt; print(url)\n        \"https://baseurl.com/api/v1/health\"\n\n        &gt;&gt;&gt; url_params = get_url(\"/users\", params=\"123\")\n        &gt;&gt;&gt; print(url_params)\n        \"https://baseurl.com/api/v1/users/123\"\n    \"\"\"\n    if api_version:\n        base_url = f\"{self.base_url}{self.api_version}{api_endpoint}\" \n    else:\n        base_url = f\"{self.base_url}{api_endpoint}\"\n\n    if params is not None:\n        return f\"{base_url}/{params}\"\n    else:\n        return base_url\n</code></pre>"},{"location":"documentation/docstring/","title":"Docstring","text":""},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient","title":"<code>TridentTraceClient</code>","text":"Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>class TridentTraceClient:\n    def __init__(\n            self, \n            base_url: str, \n            auth_token: str = None,\n            app_name: str = None,\n        ) -&gt; None:  \n        \"\"\"\n        Initializes the TridentTraceClient object.\n\n        Parameters:\n            base_url (str): Base URL of the Trident Trace service.\n            auth_token (str): Authentication token, default is None.\n            app_name (str): Application name, default is None.\n            user (str): User name, default is None.\n\n        Returns:\n            None\n        \"\"\"\n        self.base_url: str = base_url\n        self.auth_token: str = auth_token\n        self.app_name = app_name\n        self.core = CoreAPI(base_url=self.base_url, auth_token=self.auth_token)\n        self.service_domain_id = None\n        self.service_domain_slug = None\n\n        self.initialize()\n\n    def __auto_setup(self, app_name):\n        \"\"\"\n        Automatically sets up the service domain based on the app_name.\n\n        Parameters:\n            app_name (str): Application name.\n\n        Returns:\n            (int, str): A tuple containing domain_id and domain_slug.\n        \"\"\"\n        domain_id, domain_slug = self.__get_domain(app_name)\n        if domain_id is None:\n            domain_slug_res = self.__post_domain(app_name)\n            domain_id, domain_slug = self.__get_domain(domain_slug_res)\n        return domain_id, domain_slug\n\n    def initialize(self):\n        \"\"\"\n        Initializes service_domain_id and service_domain_slug if app_name is specified.\n        \"\"\"\n        if self.app_name:\n            self.service_domain_id, self.service_domain_slug = self.__auto_setup(self.app_name)\n\n\n    def get_health(self) -&gt; dict | str:\n        \"\"\"\n        Retrieves health information from the specified URL using httpx.\n\n        Returns:\n            (dict | str): Response data.\n\n        Basic Usage:\n            &gt;&gt;&gt; result = get_health()\n            &gt;&gt;&gt; print(result)\n        \"\"\"\n        health_data = self.core.get_health()\n        return health_data\n\n\n    def __get_domain(self, app_name: str) -&gt; dict | str:\n        \"\"\"\n        Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.\n\n        Parameters:\n            app_name (str): Nama aplikasi.\n\n        Returns:\n            (dict | str): Data respons atau pesan kesalahan.\n        \"\"\"\n        domain_get_data = self.core.get_domain(app_name)\n        return domain_get_data\n\n    def __post_domain(self, app_name: str) -&gt; dict | str:\n        \"\"\"\n        DOMAIN SERVICE Creates a new domain with the given app_name.\n\n        Parameters:\n            app_name (str): Application name.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        domain_post_data = self.core.post_domain(app_name)\n        return domain_post_data\n\n    def delete_domain(self, domain_id: int) -&gt; dict | str:\n        \"\"\"\n        Deletes a domain with the specified domain_id.\n\n        Parameters:\n            domain_id: Identifier of the domain to be deleted.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        domain_delete_data = self.core.delete_domain(domain_id)\n        return domain_delete_data\n\n    def get_list_inference(\n            self,\n            business_domain: str,\n            limit: int = None,\n            offset: int = None,\n            service_domain_id: Optional[int] = None,\n            service_domain_slug: Optional[str] = None,\n            ai_domain: str = None,\n            ai_subdomain: str = None,\n            user: str = None,\n            group_id: str = None,\n            order_by: str = None\n        ):\n        \"\"\"\n        INFERENCE SERVICES Get a list of inferences based on specified parameters.\n\n        Parameters:\n            business_domain (str): Business domain.\n            limit (int): Maximum number of results to return.\n            offset (int): Result offset.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_list_data = self.core.get_list_inference(\n            business_domain=business_domain,\n            limit=limit,\n            offset=offset,\n            service_domain_id=service_domain_id,\n            service_domain_slug=service_domain_slug,\n            ai_domain=ai_domain,\n            ai_subdomain=ai_subdomain,\n            user=user,\n            group_id=group_id,\n            order_by=order_by\n        )\n        # inference_get_list_data_result = convert_data(inference_get_list_data)\n        return inference_get_list_data\n\n    def get_detail_inference(self, inference_uuid) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Get detailed information about a specific inference.\n\n        Parameters:\n            inference_uuid: Identifier of the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_detail_data_result = self.core.get_detail_inference(inference_uuid)\n        if inference_get_detail_data_result:\n            for d_feed in inference_get_detail_data_result['data']['feedbacks']:\n                comments = d_feed['user_comment']\n                if \"{\" in comments[0] and  \"}\" in comments[-1]:\n                    d_feed['user_comment'] = json.loads(comments)\n        return inference_get_detail_data_result\n\n    def post_inference(\n            self,\n            data_input: str | dict,\n            data_output: str | dict,\n            inference_time: int,\n            ai_domain: str,\n            ai_subdomain: str,\n            model_version: str,\n            business_domain: str,\n            user: str, \n            image: np.ndarray | str | None = None, \n            group_id: str | None = None,\n            service_domain_id: int | None = None,\n            conf_thershold: float | None = None\n        ) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Create a new inference with the specified parameters.\n\n        Parameters:\n            data_input: Input data for the inference.\n            data_output: Output data for the inference.\n            inference_time: Time of the inference.\n            ...\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        meta_data_vision = None\n        if isinstance(image, np.ndarray):\n            meta_data_vision = FeaturesImage.compute_features(image)\n            meta_data_vision['confidence_threshold'] = conf_thershold\n            meta_data_vision = MetadataVisionSchema(**meta_data_vision)\n\n        if isinstance(data_input, dict):\n            data_input = json.dumps(data_input)\n\n        if isinstance(data_output, dict):\n            data_output = json.dumps(data_output)\n\n        body = {\n            \"data_input\": data_input,\n            \"data_output\": data_output,\n            \"inference_time\": inference_time,\n            \"business_domain\": business_domain,\n            \"service_domain_id\": service_domain_id or self.service_domain_id,\n            \"ai_domain\": ai_domain,\n            \"ai_subdomain\": ai_subdomain,\n            \"model_version\": model_version,\n            \"user\": user \n        }\n        if meta_data_vision:\n            body[\"meta_data_vision\"] = meta_data_vision.model_dump()\n        if group_id:\n            body[\"group_id\"] = group_id\n        inference_create_data = self.core.post_inference(body)\n        return inference_create_data\n\n    def delete_inference(self, inference_uuid: str) -&gt; dict | str:\n        \"\"\"\n        INFERENCE SERVICES Delete an inference with the specified inference_uuid.\n\n        Parameters:\n            inference_uuid: Identifier of the inference to be deleted.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_delete_data = self.core.delete_inference(inference_uuid)\n        return inference_delete_data\n\n    def get_group_inference(\n            self,\n            business_domain: str,\n            user: str = None,\n            limit: int = None,\n            offset: int = None,\n            service_domain_id: Optional[int] = None,\n            service_domain_slug: Optional[str] = None,\n            ai_domain: str = None,\n            ai_subdomain: str = None,\n            group_id: str = None,\n            start_date: str = None,\n            end_date: str = None\n        ):\n            \"\"\"\n            INFERENCE SERVICES Get a list of group inferences based on specified parameters.\n\n            Parameters:\n                business_domain (str): Business domain.\n                limit (int): Maximum number of results to return.\n                offset (int): Result offset.\n                ...\n\n            Returns:\n                (dict | str): Response data.\n            \"\"\"\n            inference_get_group_data = self.core.get_group_inference(\n                business_domain = business_domain,\n                limit = limit,\n                offset = offset,\n                service_domain_id = service_domain_id,\n                service_domain_slug = service_domain_slug,\n                ai_domain = ai_domain,\n                ai_subdomain = ai_subdomain,\n                user = user,\n                group_id = group_id,\n                start_date = start_date,\n                end_date = end_date\n            )\n\n            inference_get_group_data_result = convert_data(inference_get_group_data)\n            return inference_get_group_data_result\n\n\n    def get_detail_group_inference(self, group_id: str):\n        \"\"\"\n        INFERENCE SERVICES Get detailed information about a specific group inference.\n\n        Parameters:\n            group_id: Identifier of the group inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_detail_group_data = self.core.get_detail_group_inference(group_id)\n        return inference_get_detail_group_data\n\n\n    def post_feedback(\n            self, \n            inference_uuid, \n            user_reaction, \n            user_comment: str | dict, \n            user=None\n        ):\n        \"\"\"\n        FEEDBACK SERVICE Create feedback for a specific inference.\n\n        Parameters:\n            inference_uuid: Identifier of the associated inference.\n            user_reaction: User's reaction to the inference.\n            user_comment: User's comment on the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        feedback_create_data = self.core.post_feedback(\n            inference_uuid = inference_uuid, \n            user_reaction = user_reaction, \n            user_comment = user_comment, \n            user = user \n        )\n        return feedback_create_data\n\n    def update_feedback(\n            self, \n            uuid, \n            inference_uuid, \n            user_reaction: bool, \n            user_comment: str | dict, \n            user=None\n        ):\n        \"\"\"\n        FEEDBACK SERVICE Update feedback with the specified parameters.\n\n        Parameters:\n            uuid: Identifier of the feedback.\n            inference_uuid: Identifier of the associated inference.\n            user_reaction: User's updated reaction to the inference.\n            user_comment: User's updated comment on the inference.\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        feedback_update_data = self.core.update_feedback(\n            uuid = uuid,\n            inference_uuid = inference_uuid, \n            user_reaction = user_reaction, \n            user_comment = user_comment, \n            user = user \n        )\n        return feedback_update_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__auto_setup","title":"<code>__auto_setup(app_name)</code>","text":"<p>Automatically sets up the service domain based on the app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Application name.</p> required <p>Returns:</p> Type Description <code>(int, str)</code> <p>A tuple containing domain_id and domain_slug.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __auto_setup(self, app_name):\n    \"\"\"\n    Automatically sets up the service domain based on the app_name.\n\n    Parameters:\n        app_name (str): Application name.\n\n    Returns:\n        (int, str): A tuple containing domain_id and domain_slug.\n    \"\"\"\n    domain_id, domain_slug = self.__get_domain(app_name)\n    if domain_id is None:\n        domain_slug_res = self.__post_domain(app_name)\n        domain_id, domain_slug = self.__get_domain(domain_slug_res)\n    return domain_id, domain_slug\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__get_domain","title":"<code>__get_domain(app_name)</code>","text":"<p>Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Nama aplikasi.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Data respons atau pesan kesalahan.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __get_domain(self, app_name: str) -&gt; dict | str:\n    \"\"\"\n    Layanan DOMAIN Mendapatkan detail domain berdasarkan app_name.\n\n    Parameters:\n        app_name (str): Nama aplikasi.\n\n    Returns:\n        (dict | str): Data respons atau pesan kesalahan.\n    \"\"\"\n    domain_get_data = self.core.get_domain(app_name)\n    return domain_get_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__init__","title":"<code>__init__(base_url, auth_token=None, app_name=None)</code>","text":"<p>Initializes the TridentTraceClient object.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>Base URL of the Trident Trace service.</p> required <code>auth_token</code> <code>str</code> <p>Authentication token, default is None.</p> <code>None</code> <code>app_name</code> <code>str</code> <p>Application name, default is None.</p> <code>None</code> <code>user</code> <code>str</code> <p>User name, default is None.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __init__(\n        self, \n        base_url: str, \n        auth_token: str = None,\n        app_name: str = None,\n    ) -&gt; None:  \n    \"\"\"\n    Initializes the TridentTraceClient object.\n\n    Parameters:\n        base_url (str): Base URL of the Trident Trace service.\n        auth_token (str): Authentication token, default is None.\n        app_name (str): Application name, default is None.\n        user (str): User name, default is None.\n\n    Returns:\n        None\n    \"\"\"\n    self.base_url: str = base_url\n    self.auth_token: str = auth_token\n    self.app_name = app_name\n    self.core = CoreAPI(base_url=self.base_url, auth_token=self.auth_token)\n    self.service_domain_id = None\n    self.service_domain_slug = None\n\n    self.initialize()\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.__post_domain","title":"<code>__post_domain(app_name)</code>","text":"<p>DOMAIN SERVICE Creates a new domain with the given app_name.</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Application name.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def __post_domain(self, app_name: str) -&gt; dict | str:\n    \"\"\"\n    DOMAIN SERVICE Creates a new domain with the given app_name.\n\n    Parameters:\n        app_name (str): Application name.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    domain_post_data = self.core.post_domain(app_name)\n    return domain_post_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.delete_domain","title":"<code>delete_domain(domain_id)</code>","text":"<p>Deletes a domain with the specified domain_id.</p> <p>Parameters:</p> Name Type Description Default <code>domain_id</code> <code>int</code> <p>Identifier of the domain to be deleted.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def delete_domain(self, domain_id: int) -&gt; dict | str:\n    \"\"\"\n    Deletes a domain with the specified domain_id.\n\n    Parameters:\n        domain_id: Identifier of the domain to be deleted.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    domain_delete_data = self.core.delete_domain(domain_id)\n    return domain_delete_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.delete_inference","title":"<code>delete_inference(inference_uuid)</code>","text":"<p>INFERENCE SERVICES Delete an inference with the specified inference_uuid.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <code>str</code> <p>Identifier of the inference to be deleted.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def delete_inference(self, inference_uuid: str) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Delete an inference with the specified inference_uuid.\n\n    Parameters:\n        inference_uuid: Identifier of the inference to be deleted.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_delete_data = self.core.delete_inference(inference_uuid)\n    return inference_delete_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_detail_group_inference","title":"<code>get_detail_group_inference(group_id)</code>","text":"<p>INFERENCE SERVICES Get detailed information about a specific group inference.</p> <p>Parameters:</p> Name Type Description Default <code>group_id</code> <code>str</code> <p>Identifier of the group inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_detail_group_inference(self, group_id: str):\n    \"\"\"\n    INFERENCE SERVICES Get detailed information about a specific group inference.\n\n    Parameters:\n        group_id: Identifier of the group inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_detail_group_data = self.core.get_detail_group_inference(group_id)\n    return inference_get_detail_group_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_detail_inference","title":"<code>get_detail_inference(inference_uuid)</code>","text":"<p>INFERENCE SERVICES Get detailed information about a specific inference.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <p>Identifier of the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_detail_inference(self, inference_uuid) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Get detailed information about a specific inference.\n\n    Parameters:\n        inference_uuid: Identifier of the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_detail_data_result = self.core.get_detail_inference(inference_uuid)\n    if inference_get_detail_data_result:\n        for d_feed in inference_get_detail_data_result['data']['feedbacks']:\n            comments = d_feed['user_comment']\n            if \"{\" in comments[0] and  \"}\" in comments[-1]:\n                d_feed['user_comment'] = json.loads(comments)\n    return inference_get_detail_data_result\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_group_inference","title":"<code>get_group_inference(business_domain, user=None, limit=None, offset=None, service_domain_id=None, service_domain_slug=None, ai_domain=None, ai_subdomain=None, group_id=None, start_date=None, end_date=None)</code>","text":"<p>INFERENCE SERVICES Get a list of group inferences based on specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>business_domain</code> <code>str</code> <p>Business domain.</p> required <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_group_inference(\n        self,\n        business_domain: str,\n        user: str = None,\n        limit: int = None,\n        offset: int = None,\n        service_domain_id: Optional[int] = None,\n        service_domain_slug: Optional[str] = None,\n        ai_domain: str = None,\n        ai_subdomain: str = None,\n        group_id: str = None,\n        start_date: str = None,\n        end_date: str = None\n    ):\n        \"\"\"\n        INFERENCE SERVICES Get a list of group inferences based on specified parameters.\n\n        Parameters:\n            business_domain (str): Business domain.\n            limit (int): Maximum number of results to return.\n            offset (int): Result offset.\n            ...\n\n        Returns:\n            (dict | str): Response data.\n        \"\"\"\n        inference_get_group_data = self.core.get_group_inference(\n            business_domain = business_domain,\n            limit = limit,\n            offset = offset,\n            service_domain_id = service_domain_id,\n            service_domain_slug = service_domain_slug,\n            ai_domain = ai_domain,\n            ai_subdomain = ai_subdomain,\n            user = user,\n            group_id = group_id,\n            start_date = start_date,\n            end_date = end_date\n        )\n\n        inference_get_group_data_result = convert_data(inference_get_group_data)\n        return inference_get_group_data_result\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_health","title":"<code>get_health()</code>","text":"<p>Retrieves health information from the specified URL using httpx.</p> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Basic Usage <p>result = get_health() print(result)</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_health(self) -&gt; dict | str:\n    \"\"\"\n    Retrieves health information from the specified URL using httpx.\n\n    Returns:\n        (dict | str): Response data.\n\n    Basic Usage:\n        &gt;&gt;&gt; result = get_health()\n        &gt;&gt;&gt; print(result)\n    \"\"\"\n    health_data = self.core.get_health()\n    return health_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.get_list_inference","title":"<code>get_list_inference(business_domain, limit=None, offset=None, service_domain_id=None, service_domain_slug=None, ai_domain=None, ai_subdomain=None, user=None, group_id=None, order_by=None)</code>","text":"<p>INFERENCE SERVICES Get a list of inferences based on specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>business_domain</code> <code>str</code> <p>Business domain.</p> required <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>None</code> <code>offset</code> <code>int</code> <p>Result offset.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def get_list_inference(\n        self,\n        business_domain: str,\n        limit: int = None,\n        offset: int = None,\n        service_domain_id: Optional[int] = None,\n        service_domain_slug: Optional[str] = None,\n        ai_domain: str = None,\n        ai_subdomain: str = None,\n        user: str = None,\n        group_id: str = None,\n        order_by: str = None\n    ):\n    \"\"\"\n    INFERENCE SERVICES Get a list of inferences based on specified parameters.\n\n    Parameters:\n        business_domain (str): Business domain.\n        limit (int): Maximum number of results to return.\n        offset (int): Result offset.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    inference_get_list_data = self.core.get_list_inference(\n        business_domain=business_domain,\n        limit=limit,\n        offset=offset,\n        service_domain_id=service_domain_id,\n        service_domain_slug=service_domain_slug,\n        ai_domain=ai_domain,\n        ai_subdomain=ai_subdomain,\n        user=user,\n        group_id=group_id,\n        order_by=order_by\n    )\n    # inference_get_list_data_result = convert_data(inference_get_list_data)\n    return inference_get_list_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.initialize","title":"<code>initialize()</code>","text":"<p>Initializes service_domain_id and service_domain_slug if app_name is specified.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def initialize(self):\n    \"\"\"\n    Initializes service_domain_id and service_domain_slug if app_name is specified.\n    \"\"\"\n    if self.app_name:\n        self.service_domain_id, self.service_domain_slug = self.__auto_setup(self.app_name)\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.post_feedback","title":"<code>post_feedback(inference_uuid, user_reaction, user_comment, user=None)</code>","text":"<p>FEEDBACK SERVICE Create feedback for a specific inference.</p> <p>Parameters:</p> Name Type Description Default <code>inference_uuid</code> <p>Identifier of the associated inference.</p> required <code>user_reaction</code> <p>User's reaction to the inference.</p> required <code>user_comment</code> <code>str | dict</code> <p>User's comment on the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def post_feedback(\n        self, \n        inference_uuid, \n        user_reaction, \n        user_comment: str | dict, \n        user=None\n    ):\n    \"\"\"\n    FEEDBACK SERVICE Create feedback for a specific inference.\n\n    Parameters:\n        inference_uuid: Identifier of the associated inference.\n        user_reaction: User's reaction to the inference.\n        user_comment: User's comment on the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    feedback_create_data = self.core.post_feedback(\n        inference_uuid = inference_uuid, \n        user_reaction = user_reaction, \n        user_comment = user_comment, \n        user = user \n    )\n    return feedback_create_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.post_inference","title":"<code>post_inference(data_input, data_output, inference_time, ai_domain, ai_subdomain, model_version, business_domain, user, image=None, group_id=None, service_domain_id=None, conf_thershold=None)</code>","text":"<p>INFERENCE SERVICES Create a new inference with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>data_input</code> <code>str | dict</code> <p>Input data for the inference.</p> required <code>data_output</code> <code>str | dict</code> <p>Output data for the inference.</p> required <code>inference_time</code> <code>int</code> <p>Time of the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def post_inference(\n        self,\n        data_input: str | dict,\n        data_output: str | dict,\n        inference_time: int,\n        ai_domain: str,\n        ai_subdomain: str,\n        model_version: str,\n        business_domain: str,\n        user: str, \n        image: np.ndarray | str | None = None, \n        group_id: str | None = None,\n        service_domain_id: int | None = None,\n        conf_thershold: float | None = None\n    ) -&gt; dict | str:\n    \"\"\"\n    INFERENCE SERVICES Create a new inference with the specified parameters.\n\n    Parameters:\n        data_input: Input data for the inference.\n        data_output: Output data for the inference.\n        inference_time: Time of the inference.\n        ...\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    meta_data_vision = None\n    if isinstance(image, np.ndarray):\n        meta_data_vision = FeaturesImage.compute_features(image)\n        meta_data_vision['confidence_threshold'] = conf_thershold\n        meta_data_vision = MetadataVisionSchema(**meta_data_vision)\n\n    if isinstance(data_input, dict):\n        data_input = json.dumps(data_input)\n\n    if isinstance(data_output, dict):\n        data_output = json.dumps(data_output)\n\n    body = {\n        \"data_input\": data_input,\n        \"data_output\": data_output,\n        \"inference_time\": inference_time,\n        \"business_domain\": business_domain,\n        \"service_domain_id\": service_domain_id or self.service_domain_id,\n        \"ai_domain\": ai_domain,\n        \"ai_subdomain\": ai_subdomain,\n        \"model_version\": model_version,\n        \"user\": user \n    }\n    if meta_data_vision:\n        body[\"meta_data_vision\"] = meta_data_vision.model_dump()\n    if group_id:\n        body[\"group_id\"] = group_id\n    inference_create_data = self.core.post_inference(body)\n    return inference_create_data\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.TridentTraceClient.TridentTraceClient.update_feedback","title":"<code>update_feedback(uuid, inference_uuid, user_reaction, user_comment, user=None)</code>","text":"<p>FEEDBACK SERVICE Update feedback with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <p>Identifier of the feedback.</p> required <code>inference_uuid</code> <p>Identifier of the associated inference.</p> required <code>user_reaction</code> <code>bool</code> <p>User's updated reaction to the inference.</p> required <code>user_comment</code> <code>str | dict</code> <p>User's updated comment on the inference.</p> required <p>Returns:</p> Type Description <code>dict | str</code> <p>Response data.</p> Source code in <code>epyseri/integration/trident_trace/TridentTraceClient.py</code> <pre><code>def update_feedback(\n        self, \n        uuid, \n        inference_uuid, \n        user_reaction: bool, \n        user_comment: str | dict, \n        user=None\n    ):\n    \"\"\"\n    FEEDBACK SERVICE Update feedback with the specified parameters.\n\n    Parameters:\n        uuid: Identifier of the feedback.\n        inference_uuid: Identifier of the associated inference.\n        user_reaction: User's updated reaction to the inference.\n        user_comment: User's updated comment on the inference.\n\n    Returns:\n        (dict | str): Response data.\n    \"\"\"\n    feedback_update_data = self.core.update_feedback(\n        uuid = uuid,\n        inference_uuid = inference_uuid, \n        user_reaction = user_reaction, \n        user_comment = user_comment, \n        user = user \n    )\n    return feedback_update_data\n</code></pre>"},{"location":"documentation/docstring/#coreapi","title":"CoreAPI","text":"Source code in <code>epyseri/integration/trident_trace/core.py</code> <pre><code>class CoreAPI:\n    def __init__(self, base_url, auth_token, api_version=\"/api/v1\") -&gt; None:\n        self.base_url = base_url\n        self.auth_token = auth_token\n        self.api_version = api_version\n\n    def get_health(self) -&gt; dict:\n        api_endpoint = \"/health\" \n        url = get_url(self, api_endpoint, api_version=False)\n        headers = get_headers()\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Health\")['success'] \n\n    # Domain Service\n    def get_domain(self, app_name) -&gt; dict:\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint, params=slugify(app_name))\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url=url, headers=headers)\n        if response.status_code == 200:\n            data = response.json().get('data')\n            return data['id'], data['slug'] if data else (None, None)\n        else:\n            return None, None\n\n    def post_domain(self, app_name) -&gt; str | dict:\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint) \n        headers = get_headers(self.auth_token, json=True)\n        payload = {'name': f\"{app_name}\"}\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)\n        return get_response(response, \"Domain\").get('data', {})\n\n    def delete_domain(self, domain_id):\n        api_endpoint = \"/domain\"\n        url = get_url(self, api_endpoint, params=domain_id)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.delete(url, headers=headers)\n        return get_response(response, \"Domain\")['success']\n\n    # Inference Service\n    def get_list_inference(self, **kwargs):\n        api_endpoint = f\"{self.api_version}/inference\"\n        url = f\"{self.base_url}{api_endpoint}\"\n        headers = get_headers(self.auth_token)\n        filtered_kwargs = {key: value for key, value in kwargs.items() if value is not None}\n        if filtered_kwargs:\n            url += \"?\" + \"&amp;\".join(f\"{key}={value}\" for key, value in filtered_kwargs.items())\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"List Inference\")\n\n    def get_detail_inference(self, inference_uuid):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint, inference_uuid)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Detail Inference\")\n\n    def post_inference(self, body):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = body\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)  \n        return get_response(response, \"Inference\")\n\n    def delete_inference(self, inference_uuid):\n        api_endpoint = \"/inference\"\n        url = get_url(self, api_endpoint, params=inference_uuid)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.delete(url, headers=headers)\n        return get_response(response, \"Inference\")['success']\n\n    def get_group_inference(self, **kwargs):\n        api_endpoint = \"/inference/group\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token)\n        params = {key:value for key, value in dict(**kwargs).items() if value is not None}\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers, params=params)\n        return get_response(response, \"List Group Inference\")\n\n    def get_detail_group_inference(self, group_id):\n        api_endpoint = \"/inference/group\"\n        url = get_url(self, api_endpoint, group_id)\n        headers = get_headers(self.auth_token)\n        with httpx.Client() as client:\n            response = client.get(url, headers=headers)\n        return get_response(response, \"Detail Group Inference\")\n\n    # Feedback Service\n    def post_feedback(self, inference_uuid, user_reaction, user_comment, user):\n        api_endpoint = \"/feedback\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = {\n            \"inference_uuid\": inference_uuid,\n            \"user\": user,\n            \"user_reaction\": 1 if user_reaction else 0,\n            \"user_comment\": json.dumps(user_comment) if isinstance(user_comment, dict) else user_comment, \n        }\n        with httpx.Client() as client:\n            response = client.post(url, headers=headers, json=payload)\n        return get_response(response, \"Feedback\")\n\n    def update_feedback(self, uuid, inference_uuid, user_reaction, user_comment, user):\n        api_endpoint = \"/feedback\"\n        url = get_url(self, api_endpoint)\n        headers = get_headers(self.auth_token, json=True)\n        payload = {\n            \"uuid\": uuid,\n            \"inference_uuid\": inference_uuid,\n            \"user\": user,\n            \"user_reaction\": 1 if user_reaction else 0,\n            \"user_comment\": json.dumps(user_comment) if isinstance(user_comment, dict) else user_comment, \n        } \n        with httpx.Client() as client:\n            response = client.put(url, headers=headers, json=payload)   \n        return get_response(response, \"Feedback\")\n</code></pre>"},{"location":"documentation/docstring/#utils","title":"Utils","text":""},{"location":"documentation/docstring/#epyseri.integration.trident_trace.utils.convert_data","title":"<code>convert_data(inference_data, convert_to_dict=True)</code>","text":"<p>Converts the 'data_input', 'data_output', and 'user_comment' fields from JSON strings to dictionaries in the provided 'inference_data' object. Automatic conversion is applied if 'convert_to_dict' is True.</p> <p>Parameters: - inference_data (dict): The input data containing 'data' and potentially 'feedback'. - convert_to_dict (bool): A flag indicating whether to automatically convert the fields. Default is True.</p> <p>Returns: - list: A list of dictionaries containing the converted data.</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def convert_data(inference_data, convert_to_dict=True):\n    \"\"\"\n    Converts the 'data_input', 'data_output', and 'user_comment' fields from JSON strings to dictionaries\n    in the provided 'inference_data' object. Automatic conversion is applied if 'convert_to_dict' is True.\n\n    Parameters:\n    - inference_data (dict): The input data containing 'data' and potentially 'feedback'.\n    - convert_to_dict (bool): A flag indicating whether to automatically convert the fields. Default is True.\n\n    Returns:\n    - list: A list of dictionaries containing the converted data.\n    \"\"\"\n    if inference_data and inference_data.get('data') and len(inference_data['data']) &gt; 0:\n        def is_json_string(data):\n            try:\n                json.loads(data)\n                return True\n            except (json.JSONDecodeError, TypeError):\n                return False\n\n        converted_data = []\n\n        for d in inference_data.get('data', []):\n            if convert_to_dict:\n                if is_json_string(d.get('data_input')):\n                    d['data_input'] = json.loads(d['data_input'])\n                if is_json_string(d.get('data_output')):\n                    d['data_output'] = json.loads(d['data_output'])\n            if d.get('feedback'):\n                for fb in d.get('feedback'):\n                    if is_json_string(fb.get('user_comment')):\n                        fb['user_comment'] = json.loads(fb['user_comment'])\n\n            converted_data.append(d)\n\n        return converted_data\n    else:\n        return None\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.utils.get_headers","title":"<code>get_headers(auth_token=None, json=False)</code>","text":"<p>Generate headers for HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>auth_token (str</code> <p>Authentication token for authorization.</p> required <code>-</code> <code>json (bool</code> <p>If True, sets 'Content-Type' to 'application/json'.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the generated headers.</p> Example <p>get_headers(auth_token=\"your_token\", json=True) {'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': 'Bearer your_token'}</p> <p>get_headers(auth_token=\"your_token\") {'Accept': 'application/json', 'Authorization': 'Bearer your_token'}</p> <p>get_headers() {'Accept': 'application/json'}</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_headers(auth_token: str = None, json: bool = False) -&gt; dict:\n    \"\"\"\n    Generate headers for HTTP requests.\n\n    Parameters:\n        - auth_token (str, optional): Authentication token for authorization.\n        - json (bool, optional): If True, sets 'Content-Type' to 'application/json'.\n\n    Returns:\n        dict: A dictionary containing the generated headers.\n\n    Example:\n        &gt;&gt;&gt; get_headers(auth_token=\"your_token\", json=True)\n        {'Content-Type': 'application/json', 'Accept': 'application/json', 'Authorization': 'Bearer your_token'}\n\n        &gt;&gt;&gt; get_headers(auth_token=\"your_token\")\n        {'Accept': 'application/json', 'Authorization': 'Bearer your_token'}\n\n        &gt;&gt;&gt; get_headers()\n        {'Accept': 'application/json'}\n    \"\"\"\n    if auth_token:\n        if json:\n            headers = {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'Authorization': f\"Bearer {auth_token}\"\n            }\n        else:\n            headers = {\n                'Accept': 'application/json',\n                'Authorization': f\"Bearer {auth_token}\"\n            }\n    else:\n        headers = {\n            'Accept': 'application/json'\n        }\n\n    return headers\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.utils.get_response","title":"<code>get_response(response, service)</code>","text":"<p>Processes an HTTP response object and returns the JSON content if the status code is 200.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>response (httpx.Response</code> <p>The response object from an HTTP request.</p> required <code>-</code> <code>service (str</code> <p>The name of the service or endpoint called, used in error messages.</p> required <p>Returns:</p> Type Description <ul> <li>dict or None: The JSON content of the response if the status code is 200, or None if the status code is 404.</li> </ul> <p>Raises:</p> Type Description <code>-Exception</code> <p>Raised if the status code is 401 or any other code. The error message includes information about the status code, request method, service, and response text.</p> Example <p>response = client.get(url, headers=headers) result = get_response(response, \"ExampleService\")</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_response(response, service):\n    \"\"\"\n    Processes an HTTP response object and returns the JSON content if the status code is 200.\n\n    Parameters:\n        - response (httpx.Response): The response object from an HTTP request.\n        - service (str): The name of the service or endpoint called, used in error messages.\n\n    Returns:\n        - dict or None: The JSON content of the response if the status code is 200, or None if the status code is 404.\n\n    Raises:\n        - Exception: Raised if the status code is 401 or any other code. The error message includes information about the status code, request method, service, and response text.\n\n    Example:\n        &gt;&gt;&gt; response = client.get(url, headers=headers)\n        &gt;&gt;&gt; result = get_response(response, \"ExampleService\")\n    \"\"\"\n    if response.status_code == 200:\n        return response.json()\n    elif response.status_code == 401:\n        raise Exception(\"Access Denied: Insufficient Authentication Permissions.\")\n    elif response.status_code == 404:\n        return None\n    else:\n        raise Exception(f\"[{response.status_code}] Error {response.request.method} {service} to Trident Trace, {response.text}\")\n</code></pre>"},{"location":"documentation/docstring/#epyseri.integration.trident_trace.utils.get_url","title":"<code>get_url(self, api_endpoint, params=None, api_version=True)</code>","text":"<p>Generates a complete URL by incorporating the endpoint, API version, and optional parameters.</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>api_endpoint (str</code> <p>The endpoint or service path within the API.</p> required <code>-</code> <code>params (str</code> <p>Optional parameter to be added to the URL.</p> required <p>Returns:</p> Type Description <ul> <li>str: The complete URL consisting of the base URL, API version, endpoint, and optional parameter.</li> </ul> Example <p>url = get_url(\"/health\") print(url) \"https://baseurl.com/api/v1/health\"</p> <p>url_params = get_url(\"/users\", params=\"123\") print(url_params) \"https://baseurl.com/api/v1/users/123\"</p> Source code in <code>epyseri/integration/trident_trace/utils.py</code> <pre><code>def get_url(self, api_endpoint, params=None, api_version=True):\n    \"\"\"\n    Generates a complete URL by incorporating the endpoint, API version, and optional parameters.\n\n    Parameters:\n        - api_endpoint (str): The endpoint or service path within the API.\n        - params (str, optional): Optional parameter to be added to the URL.\n\n    Returns:\n        - str: The complete URL consisting of the base URL, API version, endpoint, and optional parameter.\n\n    Example:\n        &gt;&gt;&gt; url = get_url(\"/health\")\n        &gt;&gt;&gt; print(url)\n        \"https://baseurl.com/api/v1/health\"\n\n        &gt;&gt;&gt; url_params = get_url(\"/users\", params=\"123\")\n        &gt;&gt;&gt; print(url_params)\n        \"https://baseurl.com/api/v1/users/123\"\n    \"\"\"\n    if api_version:\n        base_url = f\"{self.base_url}{self.api_version}{api_endpoint}\" \n    else:\n        base_url = f\"{self.base_url}{api_endpoint}\"\n\n    if params is not None:\n        return f\"{base_url}/{params}\"\n    else:\n        return base_url\n</code></pre>"},{"location":"documentation/docstring/#schemas","title":"Schemas","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>epyseri/integration/trident_trace/schemas.py</code> <pre><code>class InferenceSchema(BaseModel):\n    business_domain: str = \"string\",\n    limit: int = 0,\n    offset: int = 0,\n    service_domain_id: Optional[List[int]] = None,\n    service_domain_slug: Optional[List[str]] = None,\n    ai_domain: str = \"string\",\n    ai_subdomain: str = \"string\",\n    user: str = \"string\",\n    group_id: str = \"string\",\n    order_by: str = \"string\"\n</code></pre> <p>             Bases: <code>BaseModel</code></p> Source code in <code>epyseri/integration/trident_trace/schemas.py</code> <pre><code>class MetadataVisionSchema(BaseModel):\n    image_size_kb: float\n    area: float\n    aspect_ratio_hw: float\n    blue_values: float\n    blur: float\n    brightness: float\n    contrast: float\n    green_values: float\n    red_values: float\n    sharpness: float\n    height: int\n    width: int\n    channels: int\n    confidence_threshold: float | None\n    saturation_std: float\n    saturation_mean: float\n</code></pre>"},{"location":"documentation/docstring/#helper","title":"Helper","text":"Source code in <code>epyseri/integration/trident_trace/helper.py</code> <pre><code>class Wrapper:\n    # we can't have a non-default-constructible Metric implementation at module level\n    class ColorMetric:\n        def __init__(\n            self,\n            color_name: str,\n            hue_filters: Union[List, List[List]],\n            saturation_filters=[50, 255],\n            value_filters=[20, 255],\n        ):\n            self.color_name = color_name\n            self.hue_filters = hue_filters\n            self.saturation_filters = saturation_filters\n            self.value_filters = value_filters\n\n            hsv_test = all(\n                0 &lt;= item &lt;= 179 for item in self.__flatten_nested_lists(hue_filters)\n            )\n            if not hsv_test:\n                raise ValueError(\"Hue parameter should be in [0, 179]\")\n\n            saturation_test = all(0 &lt;= item &lt;= 255 for item in saturation_filters)\n            if not saturation_test:\n                raise ValueError(\"Saturation parameter should be in [0, 255]\")\n\n            value_test = all(0 &lt;= item &lt;= 255 for item in value_filters)\n            if not value_test:\n                raise ValueError(\"Value parameter should be in [0, 255]\")\n\n        def __flatten_nested_lists(self, nested_list):\n            out = []\n\n            for item in nested_list:\n                if isinstance(item, list):\n                    out.extend(self.__flatten_nested_lists(item))\n                else:\n                    out.append(item)\n            return out\n\n        def compute(self, image_rgb: ndarray):\n            image = image_rgb\n            if self.color_name.lower() != \"red\":\n                mask = cv2.inRange(\n                    image,\n                    np.array(\n                        [\n                            self.hue_filters[0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                )\n                ratio = np.sum(mask &gt; 0) / (image.shape[0] * image.shape[1])\n\n            else:\n                lower_spectrum = [\n                    np.array(\n                        [\n                            self.hue_filters[0][0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[0][1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                ]\n                upper_spectrum = [\n                    np.array(\n                        [\n                            self.hue_filters[1][0],\n                            self.saturation_filters[0],\n                            self.value_filters[0],\n                        ]\n                    ),\n                    np.array(\n                        [\n                            self.hue_filters[1][1],\n                            self.saturation_filters[1],\n                            self.value_filters[1],\n                        ]\n                    ),\n                ]\n\n                lower_mask = cv2.inRange(image, lower_spectrum[0], lower_spectrum[1])\n                upper_mask = cv2.inRange(image, upper_spectrum[0], upper_spectrum[1])\n                mask = lower_mask + upper_mask\n                ratio = np.sum(mask &gt; 0) / (image.shape[0] * image.shape[1])\n            return ratio\n</code></pre>"},{"location":"usage/bussiness/","title":"Usage","text":"<p>Guide for using bussiness service in Trident Trace</p>"},{"location":"usage/bussiness/#init","title":"Init","text":"<p>PARAMETERS</p> Name Type Description Default base_url str Base URL of the Trident Trace service required auth_token str Authentication token, default is None opsional app_name str Application name, default is None opsional <p>RETURNS</p> Name Type Description Default ttc str Base URL of the Trident Trace service required <p>USAGE</p> <pre><code>from epyseri import TridentTraceClient\n\nttc = TridentTraceClient(\n    base_url=\"string\",\n    app_name=\"string\",\n    auth_token=\"string\"\n)\n\nprint(ttc.service_domain_id, ttc.service_domain_slug)\n</code></pre>"},{"location":"usage/bussiness/#health","title":"Health","text":"<p>GET <code>/health</code> - Health</p> <p>PARAMETERS</p> Name Type Description Default base_url str Base URL of the Trident Trace service required <p>RETURNS</p> Name Type Description Default ttc str Base URL of the Trident Trace service required <p>USAGE</p> <pre><code>get_health_result = ttc.get_health()\n\nprint(get_health_result)\n</code></pre>"},{"location":"usage/bussiness/#inference","title":"Inference","text":"<p>GET <code>/api/v1/inference</code> - List Inference</p> <p>PARAMETERS</p> Parameter Type Description Default business_domain str The business domain to filter the inferences. limit int (optional) The maximum number of results to return. Default is None. None offset int (optional) The result offset. Default is None. None service_domain_id int (optional) The service domain ID to filter the inferences. Default is None. None service_domain_slug str (optional) The service domain slug to filter the inferences. Default is None. None ai_domain str (optional) The AI domain to filter the inferences. Default is None. None ai_subdomain str (optional) The AI subdomain to filter the inferences. Default is None. None user str (optional) The user to filter the inferences. Default is None. None group_id str (optional) The group ID to filter the inferences. Default is None. None order_by str (optional) The field to order the inferences. Default is None. None <p>RETURNS</p> Returns Type Description Default Any A list of inferences that match the specified parameters. <p>USAGE</p> <pre><code>get_list_inference_res = ttc.get_list_inference(\"string\")\n\nprint(get_list_inference_res)\n</code></pre> <p>POST <code>/api/v1/inference</code> - Create Inference</p> <p>PARAMETERS</p> Parameter Type Description Default data_input str or dict Input data for the inference. data_output str or dict Output data for the inference. inference_time int Time of the inference. ai_domain str AI domain of the inference. ai_subdomain str AI subdomain of the inference. model_version str Version of the model used for the inference. business_domain str Business domain of the inference. user str User who performed the inference. image np.ndarray or str or None (optional) Image data used for the inference. Defaults to None. None group_id str or None (optional) Group ID of the inference. Defaults to None. None service_domain_id int or None (optional) Service domain ID of the inference. Defaults to None. None conf_threshold float or None (optional) Confidence threshold for the inference. Defaults to None. None <p>RETURNS</p> Returns Type Description Default dict or str Response data. <p>USAGE</p> <pre><code>import cv2\n\nimage = cv2.imread(\"./image.jpeg\")\n\npost_inference_res = ttc.post_inference(\n        data_input = \"string\",\n        data_output = \"string\",\n        inference_time = 0,\n        business_domain = \"string\",\n        ai_domain = \"string\",\n        ai_subdomain = \"string\",\n        model_version = \"string\",\n        group_id = \"string\",\n        user = \"test\",\n        image = image,\n)\nprint(post_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference/{inference_uuid}</code> - Detail Inference</p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid str Identifier of the inference. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>get_detail_inference_res = ttc.get_detail_inference(\"74642c5b-c4ad-49f8-b1da-2d482bb424f8\")\n\nprint(get_detail_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference</code> - List Group Inference</p> <p>PARAMETERS</p> Parameter Type Description Default data_input str or dict Input data for the inference. data_output str or dict Output data for the inference. inference_time int Time of the inference. ai_domain str AI domain of the inference. ai_subdomain str AI subdomain of the inference. model_version str Version of the model used for the inference. business_domain str Business domain of the inference. user str User who performed the inference. image np.ndarray or str or None (optional) Image data used for the inference. Defaults to None. None group_id str or None (optional) Group ID of the inference. Defaults to None. None service_domain_id int or None (optional) Service domain ID of the inference. Defaults to None. None conf_threshold float or None (optional) Confidence threshold for the inference. Defaults to None. None <p>RETURNS</p> Returns Type Description Default dict or str Response data. <p>USAGE</p> <pre><code>get_group_inference_res = ttc.get_group_inference(\n    business_domain = \"string\",\n    user=\"string\",\n    limit = 3,\n    offset = 0,\n)\n\nprint(get_group_inference_res)\n</code></pre> <p>GET <code>/api/v1/inference/{group_uuid}</code> - Detail Group Inference</p> <p>PARAMETERS</p> Parameter Type Description Default group_id str Identifier of the group inference. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>get_group_detail_inference_res = ttc.get_detail_group_inference(\"string\")\n\nprint(get_group_detail_inference_res)\n</code></pre> <p>DELETE <code>/api/v1/inference/{inference_uuid}</code> - Delete Inference</p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid str Identifier of the inference to be deleted. <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>delete_inference_res = ttc.delete_inference(\"5c462e22-dad0-46eb-9af8-fb7f34a6cf06\")\n\nprint(delete_inference_res)\n</code></pre>"},{"location":"usage/bussiness/#feedback","title":"Feedback","text":"<p>POST <code>/api/v1/inference/{inference_uuid}</code> - Create Feedback</p> <p>PARAMETERS</p> Parameter Type Description Default inference_uuid int Identifier of the associated inference. user_reaction bool User's reaction to the inference. user_comment str or dict User's comment on the inference. user str (optional) User who created the feedback. Default is None. None <p>RETURNS</p> Returns Type Description Default Any Response data. <p>USAGE</p> <pre><code>create_feedback_res = ttc.post_feedback(\n    inference_uuid=\"74642c5b-c4ad-49f8-b1da-2d482bb424f8\",\n    user_comment={\n        \"id\": 22,\n        \"user\": \"nama\",\n        \"message\": \"Test \"\n    },\n    user_reaction=True\n)\n\nprint(create_feedback_res)\n</code></pre> <p>PUT <code>/api/v1/inference/{inference_uuid}</code> - Update Feedback</p> <p>PARAMETERS</p> Parameter Type Description Default uuid str Identifier of the feedback to be updated. inference_uuid str Identifier of the associated inference. user_reaction bool User's updated reaction to the inference. user_comment str or dict User's updated comment on the inference. user str (optional) User who is updating the feedback. None <p>RETURNS</p> Returns Type Description Default Any Response data from the <code>update_feedback</code> method of the CoreAPI object. <p>USAGE</p> <pre><code>delete_inference_res = ttc.delete_inference(\"5c462e22-dad0-46eb-9af8-fb7f34a6cf06\")\n\nprint(delete_inference_res)\n</code></pre>"},{"location":"usage/model/","title":"Usage","text":"<p>Guide for using model service in Trident Trace</p>"},{"location":"usage/model/#init","title":"Init","text":"<p>PARAMETERS</p> Name Type Description Default base_url str Base URL of the Trident Trace service required auth_token str Authentication token, default is None opsional app_name str Application name, default is None opsional <p>RETURNS</p> Name Type Description Default ttc str Base URL of the Trident Trace service required <p>USAGE</p> <pre><code>from epyseri import TridentTraceClient\n\nttc = TridentTraceClient(\n    base_url=\"string\",\n    app_name=\"string\",\n    auth_token=\"string\"\n)\n\nprint(ttc.service_domain_id, ttc.service_domain_slug)\n</code></pre>"},{"location":"usage/model/#inference","title":"Inference","text":"<p>POST <code>/api/v1/inference</code> - Create Inference</p> <p>PARAMETERS</p> Parameter Type Description Default data_input str or dict Input data for the inference. data_output str or dict Output data for the inference. inference_time int Time of the inference. ai_domain str AI domain of the inference. ai_subdomain str AI subdomain of the inference. model_version str Version of the model used for the inference. business_domain str Business domain of the inference. user str User who performed the inference. image np.ndarray or str or None (optional) Image data used for the inference. Defaults to None. None group_id str or None (optional) Group ID of the inference. Defaults to None. None service_domain_id int or None (optional) Service domain ID of the inference. Defaults to None. None conf_threshold float or None (optional) Confidence threshold for the inference. Defaults to None. None <p>RETURNS</p> Returns Type Description Default dict or str Response data. <p>USAGE</p> <pre><code>import cv2\n\nimage = cv2.imread(\"./image.jpeg\")\n\npost_inference_res = ttc.post_inference(\n        data_input = \"string\",\n        data_output = \"string\",\n        inference_time = 0,\n        business_domain = \"string\",\n        ai_domain = \"string\",\n        ai_subdomain = \"string\",\n        model_version = \"string\",\n        group_id = \"string\",\n        user = \"test\",\n        image = image,\n)\nprint(post_inference_res)\n</code></pre>"},{"location":"usage/repository/","title":"Example","text":""},{"location":"usage/repository/#get-example","title":"Get example","text":"<p>https://github.com/najikh2002/techtalk-demo-package.git</p> <p>or redirect link in here</p>"}]}